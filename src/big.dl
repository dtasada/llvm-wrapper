// Type aliases
type IntPtr = *i32;
type FunctionPtr = fn(i32) void;
type<T> VectorAlias = std::vector<T>;

type OldStyleInt = i32;

// Global variables with different storage classes
var global_var: i32 = 10;
let const_global: i32 = 20;
// let comptime constexpr_global: i32 = 20;
pub const static_global: i32 = 40;

// Atomic variables
let atomic_int: std::atomic<i32> = {0};
let atomic_flag: std::atomic_flag = ATOMIC_FLAG_INIT;

// Enumerations
enum OldEnum { OLD_A, OLD_B, OLD_C };

enum ScopedEnum : char {
	SCOPED_A = 'a',
	SCOPED_B = 'b',
	SCOPED_C = 'c'
};

enum EnumStruct {
	VALUE1,
	VALUE2 = 10,
	VALUE3
	};

// Union
/* union SimpleUnion {
    int   i;
    float f;
    char  c[4];
};

union TaggedUnion {
    class {
        int type;
        int int_val;
    };

    class {
        int   type;
        float float_val;
    };

    class {
        int  type;
        char char_val;
    };
}; */

// Basic class definitions
class BasicClass {
	private_member: i32;

    prot protected_member: i32;

    pub public_member: i32;
    pub static static_member: i32;
    pub static const static_const_member: i32 = 100;
    pub static constexpr static_constexpr_member: i32 = 200;
    pub mutable mutable_member: i32;

    pub // Constructors
    pub fn BasicClass();                             // Default constructor
    pub fn BasicClass(val: i32);                      // Parameterized constructor
    pub fn BasicClass(other: &const BasicClass);      // Copy constructor
    pub fn BasicClass(other: &&BasicClass);  // Move constructor
    pub explicit fn BasicClass(val: f64);          // Explicit constructor

    // Assignment operators
    pub fn operator=(other: &const BasicClass) &BasicClass {} // Copy assignment
    pub fn operator=(other: &&BasicClass) &BasicClass;  // Move assignment

    // Destructor
    pub virtual fn ~BasicClass();

    // Member functions
    /* void         regular_function();
    const void   const_function() const;
    static void  static_function();
    virtual void virtual_function();
    virtual void pure_virtual_function() = 0;
    void         volatile_function() volatile;
    void         reference_qualified_function() &;
    void         rvalue_reference_qualified_function() &&; */

	pub fn regular_function() void;
	pub const fn const_function() void;
	pub static fn static_function() void;
	pub virtual fn virtual_function() void;
	pub abstract fn pure_virtual_function() void;
	pub volatile fn volatile_function() void;
	pub fn& reference_qualifier_function() void;
	pub fn&& rvalue_reference_qualifier_function() void;

    // Operator overloading
    /* BasicClass  operator+(const BasicClass &other) const;
    BasicClass &operator+=(const BasicClass &other);
    BasicClass  operator++(int);  // Post-increment
    BasicClass &operator++();     // Pre-increment
    bool        operator==(const BasicClass &other) const;
    bool        operator!=(const BasicClass &other) const;
    int        &operator[](size_t index);
    const int  &operator[](size_t index) const;
    operator int() const;  // Conversion operator */

	pub const fn operator+(other: &const BasicClass) BasicClass ;
    pub fn operator+=(other: &const BasicClass) &BasicClass;
    pub fn operator++(i32) BasicClass;  // Post-increment
    pub fn operator++() &BasicClass;     // Pre-increment
    pub const fn operator==(other: &const BasicClass) bool;
    pub const fn operator!=(other: &const BasicClass) bool;
    pub fn operator[](index: usize) &i32;
    pub const fn operator[](index: usize) &const i32;
    pub const fn operator i32();  // Conversion operator

    // Function call operator
    pub const fn operator()(x: i32, y: i32) i32;

    // Friend declarations
    pub friend class FriendClass;
    pub friend fn friend_function(obj: &const BasicClass) void;
    pub friend fn operator*(lhs: &const BasicClass, rhs: &const BasicClass) BasicClass;
};

// Inheritance
class DerivedClass : pub BasicClass {
    pub using BasicClass::static_function;  // Using declaration

    override fn virtual_function() void;   // Override specifier
    final fn final_function() void;        // Final specifier

    virtual fn virtual_function() void;   // Override specifier
    final fn final_function() void;        // Final specifier

    // Inheriting constructors
    using BasicClass::BasicClass;
};

// Multiple inheritance
class MultipleBase1 {
    pub abstract fn base1_function() void;
};

class MultipleBase2 {
    pub abstract fn base2_function() void;
};

class MultipleInheritance : pub MultipleBase1, MultipleBase2 {
    pub override fn base1_function() void {}

    pub override fn base2_function() void {}
};

// Virtual inheritance
class VirtualBase {
    virtual_base_member: i32 = 10;
};

class VirtualDerived1 : virtual pub VirtualBase {};

class VirtualDerived2 : virtual pub VirtualBase {};

class DiamondInheritance : pub VirtualDerived1, pub VirtualDerived2 {};

// Abstract class
class AbstractClass {
    pub abstract fn pure_virtual() void;

    pub virtual fn regular_virtual() void {}

    pub abstract fn ~AbstractClass();
};

// Final class
class FinalClass final : pub AbstractClass {
    pub override fn pure_virtual() void {}
};

// Struct (public by default)
class SimpleStruct {
    x, y: i32;

    fn SimpleStruct() = default;

    fn SimpleStruct(x, y: i32) : x(x), y(y) {}
};

// POD struct
class PODStruct {
    pub a: i32;
    pub b: f32;
    pub c: char;
};

// Template class
class<U = i32> TemplateClass {
    data: [N]T;
    secondary_data: U;

    pub fn<V> template_member_function(value: V) void;

    // Template specialization declaration
    pub fn<i32> template_member_function(value: i32) void;

    // Static member template
    pub static fn<V> static_template_function(value: V) V { return value; }
};

// Template class specialization
class<i32, f64, 5> TemplateClass {
    pub specialized_member: i32;

    pub fn specialized_function() void {}
};

// Partial template specialization
class<T, std::string, 20> TemplateClass {
    pub partial_specialized_member: T;
    pub string_member: std::string ;
};

// Variadic template
class<...Args> VariadicTemplate {
    data: std::tuple<Args...>;

    pub fn<...UArgs> VariadicTemplate(args: ...&&UArgs) : data(std::forward<UArgs>(args)...) {}

    pub fn<F> for_each(func: &&F) void {
        std::apply(
            fn(args: ...&&auto) void {
                (func(args), ...);  // Fold expression
            },
            data
        );
    }

    pub static constexpr fn size() usize { return sizeof...(Args); }
};

concept<T> Integral = std::is_integral_v<T>;

concept<T> Addable = requires(a, b: T) { a + b; };

fn<T: Integral> concept_function(value: T) void {}

fn<T> requires Addable<T> add_function(a, b: T) T { return a + b; }

// Template template parameters
class<Container: class<T>, T> TemplateTemplateClass {
    container: Container<T>;
}

// Auto and decltype
let auto_variable = 42;
let decltype_variable: decltype(auto_variable) = 100;

fn<T, U> template_auto_function(t: T, u: U) decltype(t + u) {
    return t + u;
}

// Lambda expressions
let lambda_simple                   = fn() i32 { return 42; };
let lambda_capture_by_value         = fn(x: i32) i32 { return auto_variable + x; };
let lambda_capture_by_reference     = fn(x: i32) i32 { auto_variable += x; };
let lambda_capture_all_by_value     = fn(x: i32) i32 { return auto_variable + x; };
let lambda_capture_all_by_reference = fn(x: i32) i32 { auto_variable += x; return auto_variable; };

let lambda_mutable = fn(x: i32) i32 {
    auto_variable += x;
    return auto_variable;
};
let lambda_with_return_type = fn(x: i32) f64 { return static_cast<f64>(x); };

// Template lambda (C++20)
let template_lambda = fn<T>(x, y: T) void { return x + y; };

// Function templates
fn<T> function_template(a, b: T) T { return a + b; }

// Function template specialization
fn<std::string> function_template(a, b: std::string) std::string {
    return a + " " + b;
}

// Variadic function template
fn<...Args> variadic_function(args: ...Args) void {
    ((std::cout << args << " "), ...);  // Fold expression
    std::cout << std::endl;
}

// Perfect forwarding
fn<T> perfect_forwarding_wrapper(arg: &&T) void {
    perfect_forwarding_target(std::forward<T>(arg));
}

fn perfect_forwarding_target(lvalue: &i32) void {}

fn perfect_forwarding_target(rvalue: &&i32) void {}

// CRTP (Curiously Recurring Template Pattern)
class<Derived> CRTPBase {
    pub fn interface() void { static_cast<*Derived>(this).implementation(); }
};

class CRTPDerived : pub CRTPBase<CRTPDerived> {
    pub fn implementation() void {}
};

// Function objects and functors
class Functor {
    pub const fn operator()(x, y: i32) i32 { return x + y; }
};

// Function pointers
fn regular_function(x, y: i32) i32 { return x * y; }

let function_pointer_auto = &regular_function;

// Member function pointers
class MemberFunctionClass {
    pub fn member_function(x: i32) i32 { return x * 2; }

    pub static fn static_member_function(x: i32) i32 { return x * 3; }

    pub member_variable: i32 = 10;
};

// std::function
let std_function: fn(i32, i32) i32 = function_template<i32>;

// Bind
let bound_function = std::bind(regular_function, std::placeholders::_1, 10);

// Exception handling
class CustomException : pub std::exception {
    message: std::message;

    pub fn CustomException(msg: &const std::string) : message(msg) {}

    pub const override fn what() *const char { return message.c_str(); }
};

// RAII and smart pointers
fn smart_pointer_examples() void {
	let unique_ptr: std::unique_ptr<i32> = std::make_unique<int>(42);
	let unique_array: std::unique_ptr<[]i32> = std::make_unique<[]i32>(10);

    // shared_ptr
	let shared_ptr: std::shared_ptr<i32> = std::make_shared<i32>(42);
	let weak_ptr: std::weak_ptr<i32> = shared_ptr;

    // Custom deleter
    let custom_deleter = fn(ptr: *i32) void {
        std::cout << "Custom deleting: " << *ptr << std::endl;
        delete ptr;
    };
    let custom_unique_ptr = std::unique_ptr<i32, decltype(custom_deleter)>(new i32(42), custom_deleter);
}

// Move semantics
class MoveSemantics {
    data: std::unique_ptr<i32>;

    pub fn MoveSemantics() : data(std::make_unique<i32>(0)) {}

    // Move constructor
    pub fn MoveSemantics(other: &&MoveSemantics) : data(std::move(other.data)) {}

    // Move assignment
    pub fn &operator=(other: &&MoveSemantics) MoveSemantics {
        if this != &other { data = std::move(other.data); }
        return *this;
    }

    // Deleted copy operations
    pub fn MoveSemantics(&const MoveSemantics) = delete;
    pub fn &operator=(&const MoveSemantics) MoveSemantics = delete;
}

// Reference qualifiers
class RefQualifiers {
    pub fn& lvalue_only() {}

    pub fn&& rvalue_only() {}

    pub const fn& const_lvalue_only() {}

    pub const fn&& const_rvalue_only() {}
}

// Delegating constructors
class DelegatingConstructors {
    x, y: i32;

	pub fn DelegatingConstructors() : DelegatingConstructors(0, 0) {} // Delegating

    pub fn DelegatingConstructors(x: i32) : DelegatingConstructors(x, 0) {} // Delegating

    pub fn DelegatingConstructors(x, y: i32) : x(x), y(y) {} // Target constructor
};

// Inheriting constructors
class Base {
    pub fn Base(x: i32) {}

    pub fn Base(x, y: i32) {}
};

class InheritingConstructors : pub Base {
    pub using Base::Base;                      // Inherit all constructors

    pub fn InheritingConstructors() : Base(0) {}  // Additional constructor
};

// Uniform initialization
class UniformInit {
    pub a, b, c: i32;
};

fn uniform_initialization_examples() void {
    // Brace initialization
    let ui1 = UniformInit {1, 2, 3};
    let ui2 = UniformInit {4, 5, 6};

    // Direct list initialization
    let vec = std::vector<i32>{1, 2, 3, 4, 5};

    // Copy list initialization
    let vec2: std::vector<i32> = {6, 7, 8, 9, 10};
	// WATCH THE SUBTELTY HERE WHEN WRITING COMPILER FUTURE ME

    // Initializer list
    let init_list = {1, 2, 3, 4, 5};
}

class InitializerListClass {
    pub data: std::vector<i32>;

    pub fn InitializerListClass(list: std::initializer_list<i32>) : data(list) {}
};

// Range-based for loops
fn range_based_for_examples() void {
    let vec: std::vector<i32> = {1, 2, 3, 4, 5};

    // Basic range-based for
    for element: &const i32 in vec { std::cout << element << " "; }

    // With auto
    for element in vec { std::cout << element << " "; }

    // Structured bindings (C++17)
    let map: std::map<std::string, i32> = {
        {"one", 1},
        {"two", 2}
    };

    for (key, value) in map { std::cout << key << ": " << value << std::endl; }
}

// Structured bindings (C++17)
fn structured_bindings_examples() void {
    // With std::pair
    let p: std::pair<i32, std::string> = {42, "answer"};
    let (number, text) = p;

    // With std::tuple
    let t: std::tuple<int, double, std::string> = {1, 2.5, "hello"};
    let (i, d, s) = t;

    // With arrays
	let arr: [3]i32 = {1, 2, 3};
    let (a, b, c) = arr;

    // With custom class (requires get<> specialization)
    class Point {
        pub x, y: i32;
    }

	let point = Point{10, 20};
    let (x, y) = point;
}

// Fold expressions (C++17)
fn<...Args> fold_sum(args: ...Args) auto {
    return (args + ...);  // Unary right fold
}

fn<...Args> fold_sum_with_init(args: ...Args) auto {
    return (0 + ... + args);  // Binary left fold
}

// constexpr and consteval
constexpr fn constexpr_function(x: i32) i32 { return x * x; }

let constexpr constexpr_variable: i32 = constexpr_function(10);

// consteval (C++20)
consteval fn consteval_function(x: i32) i32 { return x * x * x; }

let constexpr consteval_result: i32 = consteval_function(5);

// if constexpr (C++17)
fn<T> constexpr_if_example(value: T) void {
    constexpr if std::is_integral_v<T> {
        std::cout << "Integral: " << value << std::endl;
    } else if std::is_floating_point_v<T> {
        std::cout << "Floating point: " << value << std::endl;
    } else {
        std::cout << "Other type" << std::endl;
    }
}

// Variable templates (C++14)
let<T> constexpr pi: T = T(3.14159265358979323846);

// Class template argument deduction (C++17)
fn ctad_example() void {
	let p = std::pair{42, 3.14}; // Deduced as std::pair<int, double>
	let vec = std::vector{1, 2, 3, 4, 5}; // Deduced as std::vector<int>
}

// std::optional (C++17)
fn optional_function(condition: bool) std::optional<i32> {
    if condition { return 42; }
    return std::nullopt;
}

// std::variant (C++17)
fn variant_example() void {
    let var: std::variant<i32, f64, std::string>;

    var = 42;
    var = 3.14;
    var = std::string("hello");

    // Visit variant
    std::visit(fn(value: &const auto) void { std::cout << value << std::endl; }, var);
}

// std::any (C++17)
fn any_example() void {
    let any_var: std::any = 42;
    any_var = 3.14;
    any_var = std::string("hello");

    if any_var.type() == typeid(std::string) {
        std::cout << std::any_cast<std::string>(any_var) << std::endl;
    }
}

// String literals
fn string_literal_examples() void {
    // Regular string literals
    let c_string: *const char = "C-style string";
    let cpp_string: std::string  = "C++ string";

    // Raw string literals
    let raw_string: std::string = R"(This is a raw string with "quotes" and \backslashes)";

    // Wide string literals
    let wide_string: *const wchar_t = L"Wide string";
    let cpp_wide_string: std::wstring = L"C++ wide string";

    // UTF-8 string literals
    let utf8_string: *const char = u8"UTF-8 string: cafÃ©";

    // UTF-16 string literals
    let utf16_string: *const char16_t = u"UTF-16 string";

    // UTF-32 string literals
    let utf16_string: *const char32_t = u"UTF-32 string";

    // User-defined literals
    let binary_literal = 1010_b;  // Assuming user-defined literal
}

// User-defined literals
constexpr fn operator""_b(binary_string: *const char) u64 {
    let result: u64 = 0;
    for p in binary_string { result = result * 2 + (*p - '0'); }
    return result;
}

constexpr fn operator""_deg(degrees: f64) f64 {
    return degrees * 3.14159265358979323846 / 180.0;
}

// Attributes (C++11 and later)
[[noreturn]]
fn attribute_noreturn_function() void {
    std::exit(1);
}

[[deprecated("Use new_function instead")]]
fn attribute_deprecated_function() void {}

[[maybe_unused]]
let attribute_maybe_unused_variable: i32 = 42;

[[nodiscard]]
fn attribute_nodiscard_function() i32 {
    return 42;
}

[[fallthrough]]
fn attribute_fallthrough_example(x: i32) void {
    match x {
        1 -> { std::cout << "One"; [[fallthrough]]; };
        2 -> std::cout << "Two or fallthrough from one" << std::endl;
        _ -> {};
    }
}

// Threading and concurrency
let global_mutex: std::mutex;
let cv: std::condition_variable;
let ready = std::atomic<bool>{false};

fn thread_function(id: i32) void {
    {
        let lock = std::lock_guard<std::mutex>(global_mutex);
        std::cout << "Thread " << id << " is running" << std::endl;
    }

    // Wait for condition
    let lock = std::unique_lock<std::mutex>(global_mutex);
    cv.wait(lock, fn() void { return ready.load(); });

    std::cout << "Thread " << id << " finished waiting" << std::endl;
}

// std::async and futures
fn async_function(x: i32) i32 {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    return x * x;
}

fn async_example() void {
    // Launch async task
    let future = std::async(std::launch::async, async_function, 42);

    // Do other work...

    // Get result
    let result: i32 = future.get();
    std::cout << "Async result: " << result << std::endl;
}

// Coroutines (C++20)
class SimpleCoroutine {
    pub class promise_type {
        fn get_return_object() SimpleCoroutine {
            return SimpleCoroutine{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        fn initial_suspend() std::suspend_never { return {}; }

        fn final_suspend() std::suspend_never { return {}; }

        fn return_void() void {}

        fn unhandled_exception() void {}
    };

    pub handle: std::coroutine_handle<promise_type>;

    pub fn SimpleCoroutine(h: std::coroutine_handle<promise_type>) : handle(h) {}

    pub fn ~SimpleCoroutine() {
        if handle { handle.destroy(); }
    }
}

fn simple_coroutine() SimpleCoroutine {
    std::cout << "Coroutine started" << std::endl;
    co_await std::suspend_always{};
    std::cout << "Coroutine resumed" << std::endl;
    co_return;
}

[[alignas(16)]]
class AlignedStruct {
    data: [4]i32;
}

// Static assertions
static_assert(sizeof(i32) >= 4, "int must be at least 4 bytes");
static_assert(std::is_integral_v<i32>, "int must be integral type");

// Template metaprogramming
class<N: i32> Factorial {
    pub static constexpr value: i32 = N * Factorial<N - 1>::value;
}

class Factorial<0> {
    static constexpr value: i32 = 1;
}

let constexpr factorial_5: i32 = Factorial<5>::value;

// SFINAE (Substitution Failure Is Not An Error)
fn<T> sfinae_test(t: T) decltype((t.begin(), void())) {
    std::cout << "Has begin() method" << std::endl;
}

fn<T> sfinae_test(...) void {
    std::cout << "Does not have begin() method" << std::endl;
}

// Expression templates (basic example)
class<E> VectorExpression {
    pub const fn operator[](i: usize) f64 { return static_cast<&const E >(*this)[i]; }

    pub const fn size() usize { return static_cast<&const E>(*this).size(); }
}

class Vector : pub VectorExpression<Vector> {
    data: std::vector<f64>;

    pub fn Vector(size: usize) : data(size) {}

    pub fn &operator[](i: usize) f64 { return data[i]; }

    pub const fn operator[](i: usize) f64 { return data[i]; }

    pub const fn size() usize { return data.size(); }
}

// Placement new
fn placement_new_example() void {
    let alignas(SimpleStruct) buffer: [sizeof(SimpleStruct)]char;
    let obj: *SimpleStruct = new (buffer) SimpleStruct(10, 20);
    obj.~SimpleStruct();  // Explicit destructor call
}

/* class FunctionTryBlock {
	// Function try blocks
    value: i32;

    pub FunctionTryBlock(int v) try : value(v) {
        if (v < 0) throw std::invalid_argument("Negative value");
    } catch (const std::exception &e) {
        std::cout << "Constructor exception: " << e.what() << std::endl;
        throw;  // Must re-throw in constructor function try block
    }
} */

// Nested classes
class OuterClass {
    class PrivateNestedClass {
        data: i32;

        pub fn PrivateNestedClass(d: i32) : data(d) {}
    }

	pub class PublicNestedClass {
		data: i32;

		pub fn PublicNestedClass(d: i32) : data(d) {}

		pub class DoublyNestedClass {
			nested_data: i32;

			pub fn DoublyNestedClass(d: i32) : nested_data(d) {}
		}
	}
}

// Local classes
fn local_class_example() void {
    class LocalClass {
        data: i32;

        pub fn LocalClass(d: i32) : data(d) {}

        pub fn print() void { std::cout << "Local class data: " << data << std::endl; }
    }

    let local_obj = LocalClass(42);
    local_obj.print();
}

// Volatile keyword
fn volatile_example() void {
    let volatile volatile_var: i32 = 10;
    volatile_var = 20;  // Compiler won't optimize this away
}

// Different kinds of casts
fn casting_examples() void {
    // Static cast
    let d: f64 = 3.14;
    let i: i32 = static_cast<i32>(d);

    // Dynamic cast
    class Base {
        virtual fn ~Base() {}
    }

    class Derived : pub Base {}

    let base_ptr: *Base = new Derived();
    let derived_ptr: *Derived = dynamic_cast<*Derived>(base_ptr);

    // Const cast
    let const_int: const i32 = 42;
    let non_const_ptr: *i32 = const_cast<*i32>(&const_int);

    // Reinterpret cast
    let address: uintptr = reinterpret_cast<uintptr>(base_ptr);

    delete base_ptr;
}

// Switch statement with various cases
fn switch_example(value: i32) void {
    match value {
        1 | 2 ->  std::cout << "One or Two" << std::endl;
        3 ->  { std::cout << "Three" << std::endl; [[fallthrough]]; };
        4 ->  std::cout << "Three or Four" << std::endl;
        _ -> std::cout << "Other value" << std::endl;
    }
}

// Designated initializers (C++20)
class DesignatedInit {
    pub a, b, c: i32;
};

fn designated_initializer_example() void { let di: DesignatedInit = {.a = 1, .c = 3, .b = 2}; }

// Three-way comparison operator (C++20)
class ThreeWayComparison {
    value: i32;

    pub fn ThreeWayComparison(v: i32) : value(v) {}

    pub const fn operator<=>(other: &const ThreeWayComparison) auto = default;
    pub const fn operator==(other: &const ThreeWayComparison) bool = default;
};

// Modules (C++20) - Basic syntax
export module math_module;

export fn add(a: i32, b: i32) i32 {
    return a + b;
}

// Ranges (C++20)
fn ranges_example() void {
    let vec: std::vector<i32> = {5, 2, 8, 1, 9};

    // Sort using ranges
    std::ranges::sort(vec);

    // Filter and transform
    let even_doubled = vec | std::views::filter(fn(n: i32) i32 { return n % 2 == 0; })
                      | std::views::transform(fn(n: i32) i32 { return n * 2; });

    for value in even_doubled { std::cout << value << " "; }
}

// Concepts with requires expressions
concept<T> Printable = requires(t: T) { std::cout << t; };

concept<T> Container = requires(t: T) {
    t.begin();
    t.end();
    t.size();
};

fn<T: Printable> print_value(value: &const T) void { std::cout << value << std::endl; }

// Abbreviated function templates (C++20)
fn abbreviated_template(value: auto) void { std::cout << value << std::endl; }
fn<T> abbreviated_template(value: T) void { std::cout << value << std::endl; }

concept<T> Number = std::is_arithmetic_v<T>;

fn<T: Number> constrained_abbreviated_template(value: T) void {
    std::cout << "Number: " << value << std::endl;
}

// More advanced template metaprogramming
class<...Types> TypeList {};

class<...Types> TypeListSize<TypeList<Types...>> {
    pub static constexpr value: size_t  = sizeof...(Types);
};

// CRTP with static polymorphism
class<Derived> Drawable {
    pub const fn draw() void { static_cast<*const Derived>(this).draw_impl(); }
};

class Circle : pub Drawable<Circle> {
    pub const fn draw_impl() void { std::cout << "Drawing circle" << std::endl; }
};

class Rectangle : pub Drawable<Rectangle> {
    pub const fn draw_impl() void { std::cout << "Drawing rectangle" << std::endl; }
};

// Template argument deduction guides
class<T> DeductionGuideClass {
    value: T;

    pub fn DeductionGuideClass(v: T) : value(v) {}
};

// Inline variables (C++17)
let inline inline_variable: i32 = 42;

// Nested namespace declarations (C++17)
namespace A::B::C {
    fn nested_namespace_function() void {}
}

// constinit (C++20)
let constinit constinit_variable: i32 = 42;

// char8_t (C++20)
fn char8_example() void {
    let utf8_char: c8 = u8'a';
    let utf8_string: *const c8 = u8"Hello UTF-8";
}

// Aggregate initialization with designated initializers
class AggregateStruct {
    pub a: i32;
    pub b: f64;
    pub c: std::string;
}

fn aggregate_initialization() void {
    let agg1 = AggregateStruct{1, 2.5, "hello"};
    let agg2 = AggregateStruct{.a = 10, .b = 3.14, .c = "world"};
}

// Pack expansion in lambda captures (C++20)
fn<...Args> pack_expansion_lambda(args: ...Args) auto {
    return fn(func: auto) void { return func(args...); };
}

// Template lambda with pack expansion
fn<...Args> variadic_lambda(args: ...Args) void {
    return fn<F>(func: &&F) void { return func(args...); };
}

// Constexpr virtual functions (C++20)
class ConstexprVirtualBase {
	pub constexpr abstract const fn get_value() i32 ;
	pub constexpr virtual fn ~ConstexprVirtualBase() = default;
};

class ConstexprVirtualDerived : pub ConstexprVirtualBase {
    pub constexpr const override fn get_value() i32 { return 42; }
};

// Immediate functions (consteval) with error handling
consteval fn safe_divide_consteval(a, b: i32) i32 {
    if b == 0 { throw_std::invalid_argument("Division by zero"); } // throw deprecated in mcc?
    return a / b;
}

// More sophisticated SFINAE
class<T, U = void> has_to_string : std::false_type {};

class<T, std::void_t<decltype(std::to_string(std::declval<T>()))>> has_to_string :
    std::true_type {};

let<T> constexpr has_to_string_v: bool = has_to_string<T>::value;

// Detection idiom
type<T> to_string_t = decltype(std::to_string(std::declval<T>()));

let<T> constexpr is_to_string_valid_v: i32 = std::experimental::is_detected_v<to_string_t, T>;

// Variadic using declarations
class<...Bases> MultipleInheritanceVariadic : Bases... {
    pub using Bases::operator()...;  // Inherit all call operators
}

// Custom allocators
class<T> CustomAllocator {
	pub type value_type = T;

	pub fn CustomAllocator() = default;

	pub fn<U> CustomAllocator(&const CustomAllocator<U>) {}

	pub fn allocate(n: usize) *T { return static_cast<*T>(std::malloc(n * sizeof(T))); }

	pub fn deallocate(ptr: *T, usize) void { std::free(ptr); }

	pub const fn<U> operator==(&const CustomAllocator<U>) bool {
		return true;
	}
};

// Perfect forwarding with multiple arguments
fn<F, ...Args> invoke_with_timing(func: &&F, args: &&...Args)
    decltype(std::forward<F>(func)(std::forward<Args>(args)...)) {
    let start = std::chrono::high_resolution_clock::now();

    constexpr if std::is_void_v<decltype(func(args...))> {
        std::forward<F>(func)(std::forward<Args>(args)...);
        let end = std::chrono::high_resolution_clock::now();
        std::cout << "Execution time: "
                  << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count()
                  << " microseconds" << std::endl;
    } else {
        let result = std::forward<F>(func)(std::forward<Args>(args)...);
        let end    = std::chrono::high_resolution_clock::now();
        std::cout << "Execution time: "
                  << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count()
                  << " microseconds" << std::endl;
        return result;
    }
}

// Policy-based design
class<SortingPolicy> SortableContainer {
    data: std::vector<i32>;

    pub fn add(value: i32) void { data.push_back(value); }

    pub fn sort() void { SortingPolicy::sort(data.begin(), data.end()); }

    pub const fn print() void {
        for item: &const auto in data { std::cout << item << " "; }
        std::cout << std::endl;
    }
};

class BubbleSortPolicy {
    pub static fn<Iterator> sort(first, last: Iterator) void {
        // Bubble sort implementation
		let i = first;
        while i != last {
			let j = first;
			while j < i {
				if *i < *j { std::swap(*i, *j); }
				j++;
			}
			i++;
        }
    }
};

// Tag dispatching
class InputIteratorTag {};

class RandomAccessIteratorTag {};

fn<Iterator> advance_impl(it: &Iterator, n: i32, InputIteratorTag) void {
	for i in 0..n { ++it; }
}

fn<Iterator> advance_impl(it: &Iterator, n: i32, RandomAccessIteratorTag) void {
    it += n;
}

fn<Iterator> my_advance(it: &Iterator, n: i32) void {
    advance_impl(it, n, std::iterator_traits<Iterator>::iterator_category{});
}

// Expression SFINAE
fn<T> get_size(container: &const T) decltype(container.size()) {
    return container.size();
}

fn<T> get_size(array: &const T) decltype(sizeof(array) / sizeof(array[0])) {
    return sizeof(array) / sizeof(array[0]);
}

// Recursive template instantiation
class<N: i32> PowerOf2 {
    pub static constexpr value: i32 = 2 * PowerOf2<N - 1>::value;
};

class PowerOf2<0> {
    static constexpr value: i32 = 1;
};

// Template specialization with SFINAE
class<T, Enable = void> Serializer {
    static fn serialize(obj: &const T) std::string { return "Unknown type"; } 
};

class<T, std::enable_if_t<std::is_arithmetic_v<T>>> Serializer {
    pub static fn serialize(obj: &const T) std::string { return std::to_string(obj); }
};

class<T, std::enable_if_t<std::is_same_v<T, std::string>>> Serializer {
    pub static fn serialize(obj: &const T) std::string { return "\"" + obj + "\""; }
}

// Main function demonstrating various features
fn main() void {
    std::cout << "=== Comprehensive C++ Feature Test ===" << std::endl;

    // Basic variables and constants
    std::cout << "Global variable: " << global_var << std::endl;
    std::cout << "Constexpr global: " << constexpr_global << std::endl;
    std::cout << "Nested constant: " << nested_constant << std::endl;

    // Enums
    let scoped_val: ScopedEnum = ScopedEnum::SCOPED_A;
    std::cout << "Scoped enum value: " << static_cast<char>(scoped_val) << std::endl;

    // Unions
    let union_val: SimpleUnion;
    union_val.i = 42;
    std::cout << "Union int value: " << union_val.i << std::endl;

    // Lambda expressions
    let result = lambda_simple();
    std::cout << "Lambda result: " << result << std::endl;

    let generic_result = generic_lambda(10, 20.5);
    std::cout << "Generic lambda result: " << generic_result << std::endl;

    // Template functions
    let template_result = function_template(15, 25);
    std::cout << "Template function result: " << template_result << std::endl;

    // String template specialization
    let string_result = function_template<std::string>("Hello", "World");
    std::cout << "String template result: " << string_result << std::endl;

    // Variadic templates
    std::cout << "Variadic function output: ";
    variadic_function(1, 2.5, "test", 'c');

    let variadic_obj = VariadicTemplate<i32, f64, std::string>(42, 3.14, "hello");
    std::cout << "Variadic template size: " << variadic_obj.size() << std::endl;

    // Smart pointers
    smart_pointer_examples();

    // Exception handling
    /* try {
        exception_handling_function();
    } catch (...) { std::cout << "Caught exception in main" << std::endl; } */

    // Uniform initialization
    uniform_initialization_examples();

    // Range-based for loops
    std::cout << "Range-based for loop: ";
    range_based_for_examples();

    // Structured bindings
    structured_bindings_examples();

    // Fold expressions
    let fold_result = fold_sum(1, 2, 3, 4, 5);
    std::cout << "Fold sum result: " << fold_result << std::endl;

    // constexpr
    std::cout << "Constexpr result: " << constexpr_variable << std::endl;
    std::cout << "Consteval result: " << consteval_result << std::endl;

    // constexpr if
    constexpr_if_example(42);
    constexpr_if_example(3.14);
    constexpr_if_example("string");

    // Variable templates
    std::cout << "Pi as float: " << pi<f32> << std::endl;
    std::cout << "Pi as double: " << pi<f64> << std::endl;

    // Optional
    let opt_result = optional_function(true);
    if opt_result { std::cout << "Optional value: " << *opt_result << std::endl; }

    // Variant
    variant_example();

    // Any
    any_example();

    // String literals
    string_literal_examples();

    // User-defined literals
    let binary_value = 1010_b;
    let angle_in_radians = 90.0_deg;
    std::cout << "Binary literal 1010: " << binary_value << std::endl;
    std::cout << "90 degrees in radians: " << angle_in_radians << std::endl;

    // Attributes
    let unused_result: i32 = attribute_nodiscard_function();  // Should warn
    attribute_fallthrough_example(1);

    // Threading example
    let threads: std::vector<std::thread>;
    for i in 0..3 { threads.emplace_back(thread_function, i); }

    // Signal threads to proceed
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    {
        let lock = std::lock_guard<std::mutex>(global_mutex);
        ready = true;
    }
    cv.notify_all();

    // Wait for threads to complete
    for t: &auto in threads { t.join(); }

    // Async example
    async_example();

    // Template metaprogramming
    std::cout << "Factorial<5>: " << factorial_5 << std::endl;

    // SFINAE test
    let vec_test: std::vector<i32>;
    let str_test: std::string;
    let int_test: i32;

    std::cout << "SFINAE tests:" << std::endl;
    sfinae_test(vec_test);
    sfinae_test(int_test);

    // Placement new
    placement_new_example();

    // Local class
    local_class_example();

    // Casting examples
    casting_examples();

    // Goto example (not recommended)
    std::cout << "Goto example: ";
    goto_example();

    // Switch example
    switch_example(3);

    // Designated initializers
    designated_initializer_example();

    // Three-way comparison
    let comp1 = ThreeWayComparison(10);
    let comp2 = ThreeWayComparison(20);
    if comp1 < comp2 { std::cout << "Three-way comparison works" << std::endl; }

    // Ranges (C++20)
    /* try {
        ranges_example();
    } catch (...) { std::cout << "Ranges not fully supported in this environment" << std::endl; } */

    // Concepts
    print_value(42);
    print_value("Hello concepts");

    // Abbreviated templates
    abbreviated_template(100);
    constrained_abbreviated_template(3.14);

    // CRTP example
    let circle: Circle;
    let rectangle: Rectangle;
    circle.draw();
    rectangle.draw();

    // Template argument deduction
    let deduced = DeductionGuideClass(42);  // Type deduced as int

    // Aggregate initialization
    aggregate_initialization();

    // Pack expansion lambda
    let packed_lambda = pack_expansion_lambda(1, 2, 3);
    let lambda_result = packed_lambda(fn(a, b, c: i32) void { return a + b + c; });
    std::cout << "Pack expansion lambda result: " << lambda_result << std::endl;

    // Constexpr virtual (C++20)
    let constexpr constexpr_derived: ConstexprVirtualDerived ;
    let constexpr constexpr_virtual_result: i32 = constexpr_derived.get_value();
    std::cout << "Constexpr virtual result: " << constexpr_virtual_result << std::endl;

    // SFINAE detection
    std::cout << "has_to_string<int>: " << has_to_string_v<i32> << std::endl;
    std::cout << "has_to_string<std::string>: " << has_to_string_v<std::string> << std::endl;

    // Custom allocator
    let custom_vec: std::vector<i32, CustomAllocator<i32>>;
    custom_vec.push_back(1);
    custom_vec.push_back(2);
    custom_vec.push_back(3);

    // Perfect forwarding with timing
    let timed_result = invoke_with_timing(fn(a, b: i32) void { return a + b; }, 10, 20);
    std::cout << "Timed function result: " << timed_result << std::endl;

    // Policy-based design
    let sortable: SortableContainer<BubbleSortPolicy>;
    sortable.add(3);
    sortable.add(1);
    sortable.add(4);
    sortable.add(2);
    std::cout << "Before sorting: ";
    sortable.print();
    sortable.sort();
    std::cout << "After sorting: ";
    sortable.print();

    // Template metaprogramming
    std::cout << "2^10 = " << PowerOf2<10>::value << std::endl;

    // Serialization with template specialization
    std::cout << "Serialize int: " << Serializer<i32>::serialize(42) << std::endl;
    std::cout << "Serialize string: " << Serializer<std::string>::serialize("hello") << std::endl;
    std::cout << "Serialize custom: " << Serializer<SimpleStruct>::serialize({1, 2}) << std::endl;

    std::cout << "\n=== All C++ features demonstrated successfully! ===" << std::endl;

    return 0;
}

// Additional definitions required for compilation
let BasicClass::static_member: i32 = 0;

fn BasicClass::BasicClass() :
    private_member(0),
    protected_member(0),
    public_member(0),
    mutable_member(0) {}

fn BasicClass::BasicClass(val: i32) :
    private_member(val),
    protected_member(val),
    public_member(val),
    mutable_member(val) {}

fn BasicClass::BasicClass(other: &const BasicClass) :
    private_member(other.private_member),
    protected_member(other.protected_member),
    public_member(other.public_member),
    mutable_member(other.mutable_member) {}

fn BasicClass::BasicClass(other: &&BasicClass) :
    private_member(other.private_member),
    protected_member(other.protected_member),
    public_member(other.public_member),
    mutable_member(other.mutable_member) {}

fn BasicClass::BasicClass(val: f64) :
	private_member(static_cast<i32>(val)),
	protected_member(static_cast<i32>(val)),
	public_member(static_cast<i32>(val)),
    mutable_member(static_cast<i32>(val)) {}

fn BasicClass::operator=(other: &const BasicClass) &BasicClass {
    if this != &other {
        private_member   = other.private_member;
        protected_member = other.protected_member;
        public_member    = other.public_member;
        mutable_member   = other.mutable_member;
    }
    return *this;
}

fn BasicClass::operator=(other: &&BasicClass) &BasicClass {
    if this != &other {
        private_member   = other.private_member;
        protected_member = other.protected_member;
        public_member    = other.public_member;
        mutable_member   = other.mutable_member;
    }
    return *this;
}

fn BasicClass::~BasicClass() {}

fn BasicClass::regular_function() void {}

const fn BasicClass::const_function() void {}

fn BasicClass::static_function() void {}

fn BasicClass::virtual_function() void {}

volatile fn BasicClass::volatile_function() void {}

fn& BasicClass::reference_qualified_function() void {}

fn&& BasicClass::rvalue_reference_qualified_function() void {}

const fn BasicClass::operator+(other: &const BasicClass) BasicClass  {
    return BasicClass(this.public_member + other.public_member);
}

fn BasicClass::operator+=(other: &const BasicClass) &BasicClass {
    this.public_member += other.public_member;
    return *this;
}

fn BasicClass::operator++(i32) BasicClass {
    let temp = BasicClass(*this);
    ++public_member;
    return temp;
}

fn BasicClass::operator++() &BasicClass {
    ++public_member;
    return *this;
}

const fn BasicClass::operator==(other: &const BasicClass) bool {
    return public_member == other.public_member;
}

const fn BasicClass::operator!=(other: &const BasicClass) bool { return !(*this == other); }

fn BasicClass::operator[](index: usize) &i32 {
    return public_member;  // Simplified implementation
}

const fn &BasicClass::operator[](index: usize) const i32 {
    return public_member;  // Simplified implementation
}

const fn BasicClass::operator i32() { return public_member; }

const fn BasicClass::operator()(x, y: i32) i32 { return x + y + public_member; }

fn DerivedClass::virtual_function() void {
    std::cout << "DerivedClass::virtual_function()" << std::endl;
}

fn DerivedClass::final_function() void { std::cout << "DerivedClass::final_function()" << std::endl; }

// Template member function definitions
fn<T, U, N> TemplateClass::template_member_function(value: V) void {
    std::cout << "Template member function with value: " << value << std::endl;
}

// Friend function definition
fn friend_function(obj: &const BasicClass) void {
    std::cout << "Friend function accessing private member: " << obj.private_member << std::endl;
}

fn operator*(lhs, rhs: &const BasicClass) BasicClass {
    return BasicClass(lhs.public_member * rhs.public_member);
}

// External variable definition
let extern_global: i32 = 70;
